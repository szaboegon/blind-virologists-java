package koporscho;

import graphic.IViewable;
import graphic.SaveLoader;
import graphic.View;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Scanner;
//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Koporscho csapat Projlab 
//  @ File Name : GameController.java
//  @ Date : 2022. 03. 25.
//  @ Authors : Szab� Egon, Bir� Ferenc, T�th B�lint, Ferge M�t�, Rahmi D�niel
//
//

/**
 * A körökért és a bemenetek kezeléséért felelős osztály.
 */
public class GameController implements IViewable {
    /**
     * Az aktuális játék játékterét tárolja.
     */
    private GameMap gameMap;
    static private GameController gc = new GameController();

    /**
     * A játékban szereplő karaktereket tárolja.
     */
    private ArrayDeque<Character> chQueue = new ArrayDeque<>();
    /**
     * A játékban szereplő ágenseket tárolja.
     */
    private ArrayList<Agent> agents = new ArrayList<>();
    /**
     * A játékban szereplő felszereléseket tárolja.
     */
    private ArrayList<Equipment> equipment = new ArrayList<>();

    public static HashMap<Object, String> objectIDs = new HashMap<>();
    public static HashMap<String, Object> objectIDsInv = new HashMap<>();

    public static int bearCount = 0;
    public static boolean win = false;
    private static GameController instance = null;

    public static GameController getInstance() {
        if (instance == null) instance = new GameController();
        return instance;
    }
    private static String mapName = "";
    private boolean gameRunning = false;
    private final ArrayList<View> views = new ArrayList<>();

    public Virologist GetCurrentVirologist() {
        return (Virologist) chQueue.getFirst();
    }

    public boolean GameRunning() {
        return gameRunning;
    }

    public boolean EndTurn() {
        if (((Virologist) chQueue.peek()).GetApCurrent() == 0) {
            NextTurn();
            return true;
        }
        return false;
    }

    public boolean Move(int fieldID) {
        if (fieldID < 1 || fieldID > GetCurrentVirologist().GetField().GetNeighbors().size())
            return false;

        Field tmp = GetCurrentVirologist().GetField().GetNeighbors().get(fieldID - 1);
        GetCurrentVirologist().Move(tmp);
        NotifyViews();
        return true;
    }

    public boolean ApplyAgent(int targetID, int agentID) {
        if (targetID < 1 || targetID > GetCurrentVirologist().GetField().GetCharacters().size()
                || agentID < 1 || agentID > GetCurrentVirologist().GetAgentInventory().size())
            return false;

        Character target = GetCurrentVirologist().GetField().GetCharacters().get(targetID - 1);
        Agent agent = GetCurrentVirologist().GetAgentInventory().get(agentID - 1);
        GetCurrentVirologist().ApplyAgent(target, agent);
        NotifyViews();
        return true;
    }

    public boolean CraftAgent(int agentID) {
        if (agentID < 1 || agentID > GetCurrentVirologist().GetRecipes().size())
            return false;

        Agent agent = GetCurrentVirologist().GetRecipes().get(agentID - 1);
        GetCurrentVirologist().CraftAgent(agent);
        NotifyViews();
        return true;
    }

    public boolean DropEquipment(int equipmentID) {
        if (equipmentID < 1 || equipmentID > GetCurrentVirologist().GetEquipment().size())
            return false;

        Equipment targetEquipment = GetCurrentVirologist().GetEquipment().get(equipmentID - 1);
        GetCurrentVirologist().RemoveEquipment(targetEquipment);
        NotifyViews();
        return true;
    }

    public boolean Interact() {
        if (GetCurrentVirologist().GetField() == null)
            return false;

        GetCurrentVirologist().Interact();
        NotifyViews();
        return true;
    }

    public boolean Chop(int targetID) {
        if (targetID < 1 || targetID > GetCurrentVirologist().GetField().GetCharacters().size())
            return false;

        Character targetCharacter = GetCurrentVirologist().GetField().GetCharacters().get(targetID - 1);
        GetCurrentVirologist().Chop((Virologist) targetCharacter);
        NotifyViews();
        return true;
    }

    public boolean StealEquipment(int targetID, int equipmentID) {
        if (targetID < 1 || targetID > GetCurrentVirologist().GetField().GetCharacters().size()
                || equipmentID < 1 || equipmentID > GetCurrentVirologist().GetEquipment().size())
            return false;

        Character target = GetCurrentVirologist().GetField().GetCharacters().get(targetID - 1);
        Equipment targetEquipment = GetCurrentVirologist().GetEquipment().get(equipmentID - 1);
        GetCurrentVirologist().StealEquipment(target, targetEquipment);
        NotifyViews();
        return true;
    }

    /**
     * Elindítja a játékot a paraméterként megadott karakterekkel, ágensekkel és felszerelésekkel.
     */
    public void StartGame(String file) {
        mapName = file;
        SaveLoader.SetGc(this);
        SaveLoader.LoadGame("saves/"+file+".txt");
        gameRunning = true;
        NotifyViews();
    }

    /**
     * Leállítja a játékot, a paraméterként megadott karaktert kihirdetve győztesnek.
     */
    public void EndGame(Character c) {
        gameRunning = false;
        NotifyViews();
    }

    /**
     * Lépteti a játékot, a következő játékos körét indítja el.
     */
    public void NextTurn() {
        if (bearCount == chQueue.size()) {
            EndGame(null);
            NotifyViews();
            return;
        }
        if (agents.size() != 0 && chQueue.element().GetRecipeCount() == agents.size()) {
            win = true;
            EndGame(chQueue.element());
            NotifyViews();
            return;
        }
        chQueue.add(chQueue.remove());
        ((Virologist) chQueue.element()).RefreshAP();
        chQueue.element().Tick();
        NotifyViews();
    }

    /**
     * Hozzáad egy karaktert a játékhoz.
     *
     * @param c Új karakter
     */
    public void AddCharacter(Character c) {
        chQueue.add(c);
    }

    /**
     * Hozzáad egy ágenst a játékhoz.
     *
     * @param a Új ágens
     */
    public void AddAgent(Agent a) {
        agents.add(a);
    }

    /**
     * Alaphelyzetbe állítja a GameControllert.
     */
    public void Reset() {
        gameRunning = false;
        gc = new GameController();
        chQueue.clear();
        agents.clear();
        equipment.clear();
        NotifyViews();
    }

    public void NotifyViews() {
        for (View v : views) {
            v.Redraw(this);
        }
    }

    public void AddView(View view) {
        views.add(view);
    }

    public void RemoveView(View view) {
        views.remove(view);
    }

    public GameMap GetGameMap() {
        return gameMap;
    }

    public void SetGameMap(GameMap m) {
        gameMap = m;
    }

    public ArrayDeque<Character> GetChQueue() {
        return chQueue;
    }

    public void SetChQueue(ArrayDeque<Character> c) {
        chQueue = c;
    }

    public ArrayList<Agent> GetAgents() {
        return agents;
    }

    public void SetAgents(ArrayList<Agent> a) {
        agents = a;
    }

    public ArrayList<Equipment> GetEquipment() {
        return equipment;
    }

    public void SetEquipment(ArrayList<Equipment> e) {
        equipment = e;
    }

    public void SetObjectIDs(HashMap<Object, String> IDs) {
        objectIDs = IDs;
    }

    public void SetObjectIDsInv(HashMap<String, Object> IDs) {
        objectIDsInv = IDs;
    }

    public void LoadMap(String filename) {
        Scanner sc = new Scanner(filename);
        ArrayList<Field> temp = new ArrayList<>();
        String line = sc.nextLine();
        String[] proc = line.split(" ");
        for (int i = 1; i <= (proc.length - 1); i += 2) {
            Field f = null;
            switch (proc[i]) {
                case "city":
                    f = new City();
                    break;
                case "lab":
                    f = new Lab();
                    break;
                case "shelter":
                    f = new Shelter();
                    break;
                case "storage":
                    f = new Storage();
                    break;
            }
            String id = proc[i + 1];
            if (proc[i + 1].endsWith(";"))
                id = proc[i + 1].substring(0, proc[i + 1].length() - 1);
            objectIDs.put(f, id);
            objectIDsInv.put(id, f);
            temp.add(f);
            gameMap.GetFields().add(f);
        }

        if (temp.size() > 1) {
            for (Field f : temp) {
                System.out.println(objectIDs.get(f) + ": ");
                String[] neighbors = sc.nextLine().split(" ");
                ArrayList<Field> neighborsArr = new ArrayList<>();
                for (String id : neighbors) {
                    neighborsArr.add((Field) objectIDsInv.get(id));
                }
                f.SetNeighbors(neighborsArr);
            }
        }
    }

    public static String getMapName() {
        return mapName;
    }
}
